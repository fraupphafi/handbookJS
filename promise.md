# Promise #

Promise – это специальный объект, который содержит своё состояние, текущий результат (если есть) и коллбэки. Вначале состояние равно pending («ожидание»), затем – одно из: fulfilled («выполнено успешно») или rejected («выполнено с ошибкой»).

Синтаксис создания Promise:
```
var promise = new Promise(function(resolve, reject) {
  // Эта функция будет вызвана автоматически

  // В ней можно делать любые асинхронные операции,
  // А когда они завершатся — нужно вызвать одно из:
  // resolve(результат) при успешном выполнении
  // reject(ошибка) при ошибке
})
```

Синхронный throw – то же самое, что reject
`throw new Error("o_O");`

Универсальный метод для навешивания обработчиков:
`promise.then(onFulfilled, onRejected)`
- `onFulfilled` – функция, которая будет вызвана с результатом при resolve.
- `onRejected` – функция, которая будет вызвана с ошибкой при reject.

`.catch(error)` - обработчик на ошибку 

**Promise после reject/resolve – неизменны**

## «Чейнинг» (chaining) ##
Асинхронные цепочки из промисов

```
httpGet(...)
  .then(...)
  .then(...)
  .then(...)
```
**Если очередной then вернул промис, то далее по цепочке будет передан не сам этот промис, а его результат.**



## Promise.all ##

Вызов Promise.all(iterable) получает массив (или другой итерируемый объект) промисов и возвращает промис, который ждёт, пока все переданные промисы завершатся, и переходит в состояние «выполнено» с массивом их результатов.

```
Promise.all([
  httpGet('/article/promise/user.json'),
  httpGet('/article/promise/guest.json')
]).then(results => {
  alert(results);
});
```
Eсли какой-то из промисов завершился с ошибкой, то результатом Promise.all будет эта ошибка. При этом остальные промисы игнорируются.

## Promise.race(iterable) ##
Но, в отличие от Promise.all, результатом будет только первый успешно выполнившийся промис из списка. Остальные игнорируются.

## Promise.resolve(value) ##
Вызов Promise.resolve(value) создаёт успешно выполнившийся промис с результатом value.
Promise.resolve используют, когда хотят построить асинхронную цепочку, и начальный результат уже есть.
```
Promise.resolve(window.location) // начать с этого значения
  .then(httpGet) // вызвать для него httpGet
  .then(alert) // и вывести результат
```

## Promise.reject(error) ##
Аналогично Promise.reject(error) создаёт уже выполнившийся промис, но с ошибкой error.